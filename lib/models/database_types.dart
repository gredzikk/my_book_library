// ignore_for_file: non_constant_identifier_names, camel_case_types, file_namesimport, file_names, unnecessary_null_comparison,prefer_null_aware_operators

// WARNING: This code is auto-generated by Supadart.
// WARNING: Modifications may be overwritten. Please make changes in the SupaDart configuration.

// SDK
import 'package:supabase_flutter/supabase_flutter.dart';

// No geobase needed
// No Intl package needed
// No Dart Convert needed
// Supadart Class
abstract class SupadartClass<T> {
  static Map<String, dynamic> insert(Map<String, dynamic> data) {
    throw UnimplementedError();
  }

  static Map<String, dynamic> update(Map<String, dynamic> data) {
    throw UnimplementedError();
  }

  factory SupadartClass.fromJson(Map<String, dynamic> json) {
    throw UnimplementedError();
  }

  static converter(List<Map<String, dynamic>> data) {
    throw UnimplementedError();
  }

  static converterSingle(Map<String, dynamic> data) {
    throw UnimplementedError();
  }
}

// Supabase Client Extension
extension SupadartClient on SupabaseClient {
  SupabaseQueryBuilder get books => from('books');
  SupabaseQueryBuilder get reading_sessions => from('reading_sessions');
  SupabaseQueryBuilder get genres => from('genres');
}

// Supabase Storage Client Extension
extension SupadartStorageClient on SupabaseStorageClient {}

// Enums
// ignore: constant_identifier_names
enum BookStatus { unread, in_progress, finished, abandoned, planned }

// Utils
class Books implements SupadartClass<Books> {
  final String id;
  final String userId;
  final String? genreId;
  final String title;
  final String author;
  final int pageCount;
  final String? coverUrl;
  final String? isbn;
  final String? publisher;
  final int? publicationYear;
  final BookStatus status;
  final int lastReadPageNumber;
  final DateTime createdAt;
  final DateTime updatedAt;

  const Books({
    required this.id,
    required this.userId,
    this.genreId,
    required this.title,
    required this.author,
    required this.pageCount,
    this.coverUrl,
    this.isbn,
    this.publisher,
    this.publicationYear,
    required this.status,
    required this.lastReadPageNumber,
    required this.createdAt,
    required this.updatedAt,
  });

  static String get table_name => 'books';
  static String get c_id => 'id';
  static String get c_userId => 'user_id';
  static String get c_genreId => 'genre_id';
  static String get c_title => 'title';
  static String get c_author => 'author';
  static String get c_pageCount => 'page_count';
  static String get c_coverUrl => 'cover_url';
  static String get c_isbn => 'isbn';
  static String get c_publisher => 'publisher';
  static String get c_publicationYear => 'publication_year';
  static String get c_status => 'status';
  static String get c_lastReadPageNumber => 'last_read_page_number';
  static String get c_createdAt => 'created_at';
  static String get c_updatedAt => 'updated_at';

  static List<Books> converter(List<Map<String, dynamic>> data) {
    return data.map(Books.fromJson).toList();
  }

  static Books converterSingle(Map<String, dynamic> data) {
    return Books.fromJson(data);
  }

  static Map<String, dynamic> _generateMap({
    String? id,
    String? userId,
    String? genreId,
    String? title,
    String? author,
    int? pageCount,
    String? coverUrl,
    String? isbn,
    String? publisher,
    int? publicationYear,
    BookStatus? status,
    int? lastReadPageNumber,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return {
      if (id != null) 'id': id,
      if (userId != null) 'user_id': userId,
      if (genreId != null) 'genre_id': genreId,
      if (title != null) 'title': title,
      if (author != null) 'author': author,
      if (pageCount != null) 'page_count': pageCount,
      if (coverUrl != null) 'cover_url': coverUrl,
      if (isbn != null) 'isbn': isbn,
      if (publisher != null) 'publisher': publisher,
      if (publicationYear != null) 'publication_year': publicationYear,
      if (status != null) 'status': status.toString().split('.').last,
      if (lastReadPageNumber != null)
        'last_read_page_number': lastReadPageNumber,
      if (createdAt != null) 'created_at': createdAt.toUtc().toIso8601String(),
      if (updatedAt != null) 'updated_at': updatedAt.toUtc().toIso8601String(),
    };
  }

  static Map<String, dynamic> insert({
    String? id,
    required String userId,
    String? genreId,
    required String title,
    required String author,
    required int pageCount,
    String? coverUrl,
    String? isbn,
    String? publisher,
    int? publicationYear,
    required BookStatus status,
    required int lastReadPageNumber,
    required DateTime createdAt,
    required DateTime updatedAt,
  }) {
    return _generateMap(
      id: id,
      userId: userId,
      genreId: genreId,
      title: title,
      author: author,
      pageCount: pageCount,
      coverUrl: coverUrl,
      isbn: isbn,
      publisher: publisher,
      publicationYear: publicationYear,
      status: status,
      lastReadPageNumber: lastReadPageNumber,
      createdAt: createdAt,
      updatedAt: updatedAt,
    );
  }

  static Map<String, dynamic> update({
    String? id,
    String? userId,
    String? genreId,
    String? title,
    String? author,
    int? pageCount,
    String? coverUrl,
    String? isbn,
    String? publisher,
    int? publicationYear,
    BookStatus? status,
    int? lastReadPageNumber,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return _generateMap(
      id: id,
      userId: userId,
      genreId: genreId,
      title: title,
      author: author,
      pageCount: pageCount,
      coverUrl: coverUrl,
      isbn: isbn,
      publisher: publisher,
      publicationYear: publicationYear,
      status: status,
      lastReadPageNumber: lastReadPageNumber,
      createdAt: createdAt,
      updatedAt: updatedAt,
    );
  }

  factory Books.fromJson(Map<String, dynamic> jsonn) {
    return Books(
      id: jsonn['id'] != null ? jsonn['id'].toString() : '',
      userId: jsonn['user_id'] != null ? jsonn['user_id'].toString() : '',
      genreId: jsonn['genre_id'] != null ? jsonn['genre_id'].toString() : null,
      title: jsonn['title'] != null ? jsonn['title'].toString() : '',
      author: jsonn['author'] != null ? jsonn['author'].toString() : '',
      pageCount: jsonn['page_count'] != null
          ? int.parse(jsonn['page_count'].toString())
          : 0,
      coverUrl: jsonn['cover_url'] != null
          ? jsonn['cover_url'].toString()
          : null,
      isbn: jsonn['isbn'] != null ? jsonn['isbn'].toString() : null,
      publisher: jsonn['publisher'] != null
          ? jsonn['publisher'].toString()
          : null,
      publicationYear: jsonn['publication_year'] != null
          ? int.parse(jsonn['publication_year'].toString())
          : null,
      status: jsonn['status'] != null
          ? BookStatus.values.byName(jsonn['status'].toString())
          : BookStatus.values.first,
      lastReadPageNumber: jsonn['last_read_page_number'] != null
          ? int.parse(jsonn['last_read_page_number'].toString())
          : 0,
      createdAt: jsonn['created_at'] != null
          ? DateTime.parse(jsonn['created_at'].toString())
          : DateTime.fromMillisecondsSinceEpoch(0),
      updatedAt: jsonn['updated_at'] != null
          ? DateTime.parse(jsonn['updated_at'].toString())
          : DateTime.fromMillisecondsSinceEpoch(0),
    );
  }

  Map<String, dynamic> toJson() {
    return _generateMap(
      id: id,
      userId: userId,
      genreId: genreId,
      title: title,
      author: author,
      pageCount: pageCount,
      coverUrl: coverUrl,
      isbn: isbn,
      publisher: publisher,
      publicationYear: publicationYear,
      status: status,
      lastReadPageNumber: lastReadPageNumber,
      createdAt: createdAt,
      updatedAt: updatedAt,
    );
  }
}

class ReadingSessions implements SupadartClass<ReadingSessions> {
  final String id;
  final String userId;
  final String bookId;
  final DateTime startTime;
  final DateTime endTime;
  final int durationMinutes;
  final int pagesRead;
  final int lastReadPageNumber;
  final DateTime createdAt;

  const ReadingSessions({
    required this.id,
    required this.userId,
    required this.bookId,
    required this.startTime,
    required this.endTime,
    required this.durationMinutes,
    required this.pagesRead,
    required this.lastReadPageNumber,
    required this.createdAt,
  });

  static String get table_name => 'reading_sessions';
  static String get c_id => 'id';
  static String get c_userId => 'user_id';
  static String get c_bookId => 'book_id';
  static String get c_startTime => 'start_time';
  static String get c_endTime => 'end_time';
  static String get c_durationMinutes => 'duration_minutes';
  static String get c_pagesRead => 'pages_read';
  static String get c_lastReadPageNumber => 'last_read_page_number';
  static String get c_createdAt => 'created_at';

  static List<ReadingSessions> converter(List<Map<String, dynamic>> data) {
    return data.map(ReadingSessions.fromJson).toList();
  }

  static ReadingSessions converterSingle(Map<String, dynamic> data) {
    return ReadingSessions.fromJson(data);
  }

  static Map<String, dynamic> _generateMap({
    String? id,
    String? userId,
    String? bookId,
    DateTime? startTime,
    DateTime? endTime,
    int? durationMinutes,
    int? pagesRead,
    int? lastReadPageNumber,
    DateTime? createdAt,
  }) {
    return {
      if (id != null) 'id': id,
      if (userId != null) 'user_id': userId,
      if (bookId != null) 'book_id': bookId,
      if (startTime != null) 'start_time': startTime.toUtc().toIso8601String(),
      if (endTime != null) 'end_time': endTime.toUtc().toIso8601String(),
      if (durationMinutes != null) 'duration_minutes': durationMinutes,
      if (pagesRead != null) 'pages_read': pagesRead,
      if (lastReadPageNumber != null)
        'last_read_page_number': lastReadPageNumber,
      if (createdAt != null) 'created_at': createdAt.toUtc().toIso8601String(),
    };
  }

  static Map<String, dynamic> insert({
    String? id,
    required String userId,
    required String bookId,
    required DateTime startTime,
    required DateTime endTime,
    required int durationMinutes,
    required int pagesRead,
    required int lastReadPageNumber,
    required DateTime createdAt,
  }) {
    return _generateMap(
      id: id,
      userId: userId,
      bookId: bookId,
      startTime: startTime,
      endTime: endTime,
      durationMinutes: durationMinutes,
      pagesRead: pagesRead,
      lastReadPageNumber: lastReadPageNumber,
      createdAt: createdAt,
    );
  }

  static Map<String, dynamic> update({
    String? id,
    String? userId,
    String? bookId,
    DateTime? startTime,
    DateTime? endTime,
    int? durationMinutes,
    int? pagesRead,
    int? lastReadPageNumber,
    DateTime? createdAt,
  }) {
    return _generateMap(
      id: id,
      userId: userId,
      bookId: bookId,
      startTime: startTime,
      endTime: endTime,
      durationMinutes: durationMinutes,
      pagesRead: pagesRead,
      lastReadPageNumber: lastReadPageNumber,
      createdAt: createdAt,
    );
  }

  factory ReadingSessions.fromJson(Map<String, dynamic> jsonn) {
    return ReadingSessions(
      id: jsonn['id'] != null ? jsonn['id'].toString() : '',
      userId: jsonn['user_id'] != null ? jsonn['user_id'].toString() : '',
      bookId: jsonn['book_id'] != null ? jsonn['book_id'].toString() : '',
      startTime: jsonn['start_time'] != null
          ? DateTime.parse(jsonn['start_time'].toString())
          : DateTime.fromMillisecondsSinceEpoch(0),
      endTime: jsonn['end_time'] != null
          ? DateTime.parse(jsonn['end_time'].toString())
          : DateTime.fromMillisecondsSinceEpoch(0),
      durationMinutes: jsonn['duration_minutes'] != null
          ? int.parse(jsonn['duration_minutes'].toString())
          : 0,
      pagesRead: jsonn['pages_read'] != null
          ? int.parse(jsonn['pages_read'].toString())
          : 0,
      lastReadPageNumber: jsonn['last_read_page_number'] != null
          ? int.parse(jsonn['last_read_page_number'].toString())
          : 0,
      createdAt: jsonn['created_at'] != null
          ? DateTime.parse(jsonn['created_at'].toString())
          : DateTime.fromMillisecondsSinceEpoch(0),
    );
  }

  Map<String, dynamic> toJson() {
    return _generateMap(
      id: id,
      userId: userId,
      bookId: bookId,
      startTime: startTime,
      endTime: endTime,
      durationMinutes: durationMinutes,
      pagesRead: pagesRead,
      lastReadPageNumber: lastReadPageNumber,
      createdAt: createdAt,
    );
  }
}

class Genres implements SupadartClass<Genres> {
  final String id;
  final String name;
  final DateTime createdAt;

  const Genres({required this.id, required this.name, required this.createdAt});

  static String get table_name => 'genres';
  static String get c_id => 'id';
  static String get c_name => 'name';
  static String get c_createdAt => 'created_at';

  static List<Genres> converter(List<Map<String, dynamic>> data) {
    return data.map(Genres.fromJson).toList();
  }

  static Genres converterSingle(Map<String, dynamic> data) {
    return Genres.fromJson(data);
  }

  static Map<String, dynamic> _generateMap({
    String? id,
    String? name,
    DateTime? createdAt,
  }) {
    return {
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (createdAt != null) 'created_at': createdAt.toUtc().toIso8601String(),
    };
  }

  static Map<String, dynamic> insert({
    String? id,
    required String name,
    required DateTime createdAt,
  }) {
    return _generateMap(id: id, name: name, createdAt: createdAt);
  }

  static Map<String, dynamic> update({
    String? id,
    String? name,
    DateTime? createdAt,
  }) {
    return _generateMap(id: id, name: name, createdAt: createdAt);
  }

  factory Genres.fromJson(Map<String, dynamic> jsonn) {
    return Genres(
      id: jsonn['id'] != null ? jsonn['id'].toString() : '',
      name: jsonn['name'] != null ? jsonn['name'].toString() : '',
      createdAt: jsonn['created_at'] != null
          ? DateTime.parse(jsonn['created_at'].toString())
          : DateTime.fromMillisecondsSinceEpoch(0),
    );
  }

  Map<String, dynamic> toJson() {
    return _generateMap(id: id, name: name, createdAt: createdAt);
  }
}
